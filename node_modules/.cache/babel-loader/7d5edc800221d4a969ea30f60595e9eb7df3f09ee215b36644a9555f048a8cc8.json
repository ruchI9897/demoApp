{"ast":null,"code":"/*\n * Swipe 2.0.0\n * Brad Birdsall\n * https://github.com/thebird/Swipe\n * Copyright 2013-2015, MIT License\n *\n */\n\n(function (root, factory) {\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Swipe = factory();\n  }\n})(this, function () {\n  'use strict';\n\n  return function Swipe(container, options) {\n    // utilities\n    var noop = function () {}; // simple no operation function\n    var offloadFn = function (fn) {\n      setTimeout(fn || noop, 0);\n    }; // offload a functions execution\n\n    // check browser capabilities\n    var browser = {\n      addEventListener: !!window.addEventListener,\n      touch: 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,\n      transitions: function (temp) {\n        var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];\n        for (var i in props) if (temp.style[props[i]] !== undefined) return true;\n        return false;\n      }(document.createElement('swipe'))\n    };\n\n    // quit if no root element\n    if (!container) return;\n    var element = container.children[0];\n    var slides, slidePos, width, length;\n    options = options || {};\n    var index = parseInt(options.startSlide, 10) || 0;\n    var speed = options.speed || 300;\n    var widthOfSiblingSlidePreview = parseInt(options.widthOfSiblingSlidePreview, 10) || 0;\n    var continuous = options.continuous = options.continuous !== undefined ? options.continuous : true;\n    function setup() {\n      // cache slides\n      slides = element.children;\n      length = slides.length;\n\n      // set continuous to false if only one slide\n      continuous = slides.length < 2 ? false : options.continuous;\n\n      // create an array to store current positions of each slide\n      slidePos = new Array(slides.length);\n\n      // determine width of each slide\n      width = Math.round(container.getBoundingClientRect().width || container.offsetWidth) - widthOfSiblingSlidePreview * 2;\n      element.style.width = slides.length * width + 'px';\n\n      // stack elements\n      var pos = slides.length;\n      while (pos--) {\n        var slide = slides[pos];\n        slide.style.width = width + 'px';\n        slide.setAttribute('data-index', pos);\n        if (browser.transitions) {\n          slide.style.left = pos * -width + widthOfSiblingSlidePreview + 'px';\n          move(pos, index > pos ? -width : index < pos ? width : 0, 0);\n        }\n      }\n\n      // reposition elements before and after index\n      if (continuous && browser.transitions) {\n        move(circle(index - 1), -width, 0);\n        move(circle(index + 1), width, 0);\n      }\n      if (!browser.transitions) element.style.left = index * -width + widthOfSiblingSlidePreview + 'px';\n      container.style.visibility = 'visible';\n    }\n    function prev() {\n      if (continuous) slide(index - 1);else if (index) slide(index - 1);\n    }\n    function next() {\n      if (continuous) slide(index + 1);else if (index < slides.length - 1) slide(index + 1);\n    }\n    function circle(index) {\n      // a simple positive modulo using slides.length\n      return (slides.length + index % slides.length) % slides.length;\n    }\n    function slide(to, slideSpeed) {\n      // do nothing if already on requested slide\n      if (index == to) return;\n      if (browser.transitions) {\n        var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward\n\n        // get the actual position of the slide\n        if (continuous) {\n          var natural_direction = direction;\n          direction = -slidePos[circle(to)] / width;\n\n          // if going forward but to < index, use to = slides.length + to\n          // if going backward but to > index, use to = -slides.length + to\n          if (direction !== natural_direction) to = -direction * slides.length + to;\n        }\n        var diff = Math.abs(index - to) - 1;\n\n        // move all the slides between index and to in the right direction\n        while (diff--) move(circle((to > index ? to : index) - diff - 1), width * direction, 0);\n        to = circle(to);\n        move(index, width * direction, slideSpeed || speed);\n        move(to, 0, slideSpeed || speed);\n        if (continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\n      } else {\n        to = circle(to);\n        animate(index * -width, to * -width, slideSpeed || speed);\n        //no fallback for a circular continuous if the browser does not accept transitions\n      }\n\n      index = to;\n      offloadFn(options.callback && options.callback(index, slides[index]));\n    }\n    function move(index, dist, speed) {\n      translate(index, dist, speed);\n      slidePos[index] = dist;\n    }\n    function translate(index, dist, speed) {\n      var slide = slides[index];\n      var style = slide && slide.style;\n      if (!style) return;\n      style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + 'ms';\n      style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';\n      style.msTransform = style.MozTransform = style.OTransform = 'translateX(' + dist + 'px)';\n    }\n    function animate(from, to, speed) {\n      // if not an animation, just reposition\n      if (!speed) {\n        element.style.left = to + 'px';\n        return;\n      }\n      var start = +new Date();\n      var timer = setInterval(function () {\n        var timeElap = +new Date() - start;\n        if (timeElap > speed) {\n          element.style.left = to + 'px';\n          if (delay) begin();\n          options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n          clearInterval(timer);\n          return;\n        }\n        element.style.left = (to - from) * (Math.floor(timeElap / speed * 100) / 100) + from + 'px';\n      }, 4);\n    }\n\n    // setup auto slideshow\n    var delay = options.auto || 0;\n    var interval;\n    function begin() {\n      clearTimeout(interval);\n      interval = setTimeout(next, delay);\n    }\n    function stop() {\n      delay = 0;\n      clearTimeout(interval);\n    }\n\n    // setup initial vars\n    var start = {};\n    var delta = {};\n    var isScrolling;\n\n    // setup event capturing\n    var events = {\n      handleEvent: function (event) {\n        switch (event.type) {\n          case 'touchstart':\n            this.start(event);\n            break;\n          case 'touchmove':\n            this.move(event);\n            break;\n          case 'touchend':\n            offloadFn(this.end(event));\n            break;\n          case 'webkitTransitionEnd':\n          case 'msTransitionEnd':\n          case 'oTransitionEnd':\n          case 'otransitionend':\n          case 'transitionend':\n            offloadFn(this.transitionEnd(event));\n            break;\n          case 'resize':\n            offloadFn(setup);\n            break;\n        }\n        if (options.stopPropagation) event.stopPropagation();\n      },\n      start: function (event) {\n        var touches = event.touches[0];\n\n        // measure start values\n        start = {\n          // get initial touch coords\n          x: touches.pageX,\n          y: touches.pageY,\n          // store time to determine touch duration\n          time: +new Date()\n        };\n\n        // used for testing first move event\n        isScrolling = undefined;\n\n        // reset delta and end measurements\n        delta = {};\n\n        // attach touchmove and touchend listeners\n        element.addEventListener('touchmove', this, false);\n        element.addEventListener('touchend', this, false);\n      },\n      move: function (event) {\n        // ensure swiping with one touch and not pinching\n        if (event.touches.length > 1 || event.scale && event.scale !== 1) return;\n        if (options.disableScroll) return;\n        var touches = event.touches[0];\n\n        // measure change in x and y\n        delta = {\n          x: touches.pageX - start.x,\n          y: touches.pageY - start.y\n        };\n\n        // determine if scrolling test has run - one time test\n        if (typeof isScrolling == 'undefined') {\n          isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));\n        }\n\n        // if user is not trying to scroll vertically\n        if (!isScrolling) {\n          // prevent native scrolling\n          event.preventDefault();\n\n          // stop slideshow\n          stop();\n\n          // increase resistance if first or last slide\n          if (continuous) {\n            // we don't add resistance at the end\n\n            translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);\n            translate(index, delta.x + slidePos[index], 0);\n            translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);\n          } else {\n            delta.x = delta.x / (!index && delta.x > 0 ||\n            // if first slide and sliding left\n            index == slides.length - 1 &&\n            // or if last slide and sliding right\n            delta.x < 0 // and if sliding at all\n            ? Math.abs(delta.x) / width + 1 // determine resistance level\n            : 1); // no resistance if false\n\n            // translate 1:1\n            translate(index - 1, delta.x + slidePos[index - 1], 0);\n            translate(index, delta.x + slidePos[index], 0);\n            translate(index + 1, delta.x + slidePos[index + 1], 0);\n          }\n          options.swiping && options.swiping(-delta.x / width);\n        }\n      },\n      end: function (event) {\n        // measure duration\n        var duration = +new Date() - start.time;\n\n        // determine if slide attempt triggers next/prev slide\n        var isValidSlide = Number(duration) < 250 &&\n        // if slide duration is less than 250ms\n        Math.abs(delta.x) > 20 ||\n        // and if slide amt is greater than 20px\n        Math.abs(delta.x) > width / 2; // or if slide amt is greater than half the width\n\n        // determine if slide attempt is past start and end\n        var isPastBounds = !index && delta.x > 0 ||\n        // if first slide and slide amt is greater than 0\n        index == slides.length - 1 && delta.x < 0; // or if last slide and slide amt is less than 0\n\n        if (continuous) isPastBounds = false;\n\n        // determine direction of swipe (true:right, false:left)\n        var direction = delta.x < 0;\n\n        // if not scrolling vertically\n        if (!isScrolling) {\n          if (isValidSlide && !isPastBounds) {\n            if (direction) {\n              if (continuous) {\n                // we need to get the next in this direction in place\n\n                move(circle(index - 1), -width, 0);\n                move(circle(index + 2), width, 0);\n              } else {\n                move(index - 1, -width, 0);\n              }\n              move(index, slidePos[index] - width, speed);\n              move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);\n              index = circle(index + 1);\n            } else {\n              if (continuous) {\n                // we need to get the next in this direction in place\n\n                move(circle(index + 1), width, 0);\n                move(circle(index - 2), -width, 0);\n              } else {\n                move(index + 1, width, 0);\n              }\n              move(index, slidePos[index] + width, speed);\n              move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);\n              index = circle(index - 1);\n            }\n            options.callback && options.callback(index, slides[index]);\n          } else {\n            if (continuous) {\n              move(circle(index - 1), -width, speed);\n              move(index, 0, speed);\n              move(circle(index + 1), width, speed);\n            } else {\n              move(index - 1, -width, speed);\n              move(index, 0, speed);\n              move(index + 1, width, speed);\n            }\n          }\n        }\n\n        // kill touchmove and touchend event listeners until touchstart called again\n        element.removeEventListener('touchmove', events, false);\n        element.removeEventListener('touchend', events, false);\n        element.removeEventListener('touchforcechange', function () {}, false);\n      },\n      transitionEnd: function (event) {\n        if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\n          if (delay) begin();\n          options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n        }\n      }\n    };\n\n    // trigger setup\n    setup();\n\n    // start auto slideshow if applicable\n    if (delay) begin();\n\n    // add event listeners\n    if (browser.addEventListener) {\n      // set touchstart event on element\n      if (browser.touch) {\n        element.addEventListener('touchstart', events, false);\n        element.addEventListener('touchforcechange', function () {}, false);\n      }\n      if (browser.transitions) {\n        element.addEventListener('webkitTransitionEnd', events, false);\n        element.addEventListener('msTransitionEnd', events, false);\n        element.addEventListener('oTransitionEnd', events, false);\n        element.addEventListener('otransitionend', events, false);\n        element.addEventListener('transitionend', events, false);\n      }\n\n      // set resize event on window\n      window.addEventListener('resize', events, false);\n    } else {\n      window.onresize = function () {\n        setup();\n      }; // to play nice with old IE\n    }\n\n    // expose the Swipe API\n    return {\n      setup: function () {\n        setup();\n      },\n      slide: function (to, speed) {\n        // cancel slideshow\n        stop();\n        slide(to, speed);\n      },\n      prev: function () {\n        // cancel slideshow\n        stop();\n        prev();\n      },\n      next: function () {\n        // cancel slideshow\n        stop();\n        next();\n      },\n      stop: function () {\n        // cancel slideshow\n        stop();\n      },\n      getPos: function () {\n        // return current index position\n        return index;\n      },\n      getNumSlides: function () {\n        // return total number of slides\n        return length;\n      },\n      kill: function () {\n        // cancel slideshow\n        stop();\n\n        // reset element\n        element.style.width = '';\n        element.style.left = '';\n\n        // reset slides\n        var pos = slides.length;\n        while (pos--) {\n          var slide = slides[pos];\n          slide.style.width = '';\n          slide.style.left = '';\n          if (browser.transitions) translate(pos, 0, 0);\n        }\n\n        // removed event listeners\n        if (browser.addEventListener) {\n          // remove current event listeners\n          element.removeEventListener('touchstart', events, false);\n          element.removeEventListener('webkitTransitionEnd', events, false);\n          element.removeEventListener('msTransitionEnd', events, false);\n          element.removeEventListener('oTransitionEnd', events, false);\n          element.removeEventListener('otransitionend', events, false);\n          element.removeEventListener('transitionend', events, false);\n          window.removeEventListener('resize', events, false);\n        } else {\n          window.onresize = null;\n        }\n      }\n    };\n  };\n});","map":{"version":3,"names":["root","factory","module","exports","Swipe","container","options","noop","offloadFn","fn","setTimeout","browser","addEventListener","window","touch","DocumentTouch","document","transitions","temp","props","i","style","undefined","createElement","element","children","slides","slidePos","width","length","index","parseInt","startSlide","speed","widthOfSiblingSlidePreview","continuous","setup","Array","Math","round","getBoundingClientRect","offsetWidth","pos","slide","setAttribute","left","move","circle","visibility","prev","next","to","slideSpeed","direction","abs","natural_direction","diff","animate","callback","dist","translate","webkitTransitionDuration","MozTransitionDuration","msTransitionDuration","OTransitionDuration","transitionDuration","webkitTransform","msTransform","MozTransform","OTransform","from","start","Date","timer","setInterval","timeElap","delay","begin","transitionEnd","call","event","clearInterval","floor","auto","interval","clearTimeout","stop","delta","isScrolling","events","handleEvent","type","end","stopPropagation","touches","x","pageX","y","pageY","time","scale","disableScroll","preventDefault","swiping","duration","isValidSlide","Number","isPastBounds","removeEventListener","target","getAttribute","onresize","getPos","getNumSlides","kill"],"sources":["/Users/ruchianand/Documents/Company/carousel-with-menu/node_modules/swipe-js-iso/swipe.js"],"sourcesContent":["/*\n * Swipe 2.0.0\n * Brad Birdsall\n * https://github.com/thebird/Swipe\n * Copyright 2013-2015, MIT License\n *\n */\n\n(function(root, factory) {\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Swipe = factory();\n  }\n})(this, function() {\n  'use strict';\n\n  return function Swipe(container, options) {\n    // utilities\n    var noop = function() {}; // simple no operation function\n    var offloadFn = function(fn) {\n      setTimeout(fn || noop, 0);\n    }; // offload a functions execution\n\n    // check browser capabilities\n    var browser = {\n      addEventListener: !!window.addEventListener,\n      touch:\n        'ontouchstart' in window ||\n        (window.DocumentTouch && document instanceof window.DocumentTouch),\n      transitions: (function(temp) {\n        var props = [\n          'transitionProperty',\n          'WebkitTransition',\n          'MozTransition',\n          'OTransition',\n          'msTransition'\n        ];\n        for (var i in props)\n          if (temp.style[props[i]] !== undefined) return true;\n        return false;\n      })(document.createElement('swipe'))\n    };\n\n    // quit if no root element\n    if (!container) return;\n    var element = container.children[0];\n    var slides, slidePos, width, length;\n    options = options || {};\n    var index = parseInt(options.startSlide, 10) || 0;\n    var speed = options.speed || 300;\n    var widthOfSiblingSlidePreview =\n      parseInt(options.widthOfSiblingSlidePreview, 10) || 0;\n    var continuous = (options.continuous =\n      options.continuous !== undefined ? options.continuous : true);\n\n    function setup() {\n      // cache slides\n      slides = element.children;\n      length = slides.length;\n\n      // set continuous to false if only one slide\n      continuous = slides.length < 2 ? false : options.continuous;\n\n      // create an array to store current positions of each slide\n      slidePos = new Array(slides.length);\n\n      // determine width of each slide\n      width =\n        Math.round(\n          container.getBoundingClientRect().width || container.offsetWidth\n        ) -\n        widthOfSiblingSlidePreview * 2;\n\n      element.style.width = slides.length * width + 'px';\n\n      // stack elements\n      var pos = slides.length;\n      while (pos--) {\n        var slide = slides[pos];\n\n        slide.style.width = width + 'px';\n        slide.setAttribute('data-index', pos);\n\n        if (browser.transitions) {\n          slide.style.left = pos * -width + widthOfSiblingSlidePreview + 'px';\n          move(pos, index > pos ? -width : index < pos ? width : 0, 0);\n        }\n      }\n\n      // reposition elements before and after index\n      if (continuous && browser.transitions) {\n        move(circle(index - 1), -width, 0);\n        move(circle(index + 1), width, 0);\n      }\n\n      if (!browser.transitions)\n        element.style.left = index * -width + widthOfSiblingSlidePreview + 'px';\n\n      container.style.visibility = 'visible';\n    }\n\n    function prev() {\n      if (continuous) slide(index - 1);\n      else if (index) slide(index - 1);\n    }\n\n    function next() {\n      if (continuous) slide(index + 1);\n      else if (index < slides.length - 1) slide(index + 1);\n    }\n\n    function circle(index) {\n      // a simple positive modulo using slides.length\n      return (slides.length + (index % slides.length)) % slides.length;\n    }\n\n    function slide(to, slideSpeed) {\n      // do nothing if already on requested slide\n      if (index == to) return;\n\n      if (browser.transitions) {\n        var direction = Math.abs(index - to) / (index - to); // 1: backward, -1: forward\n\n        // get the actual position of the slide\n        if (continuous) {\n          var natural_direction = direction;\n          direction = -slidePos[circle(to)] / width;\n\n          // if going forward but to < index, use to = slides.length + to\n          // if going backward but to > index, use to = -slides.length + to\n          if (direction !== natural_direction)\n            to = -direction * slides.length + to;\n        }\n\n        var diff = Math.abs(index - to) - 1;\n\n        // move all the slides between index and to in the right direction\n        while (diff--)\n          move(\n            circle((to > index ? to : index) - diff - 1),\n            width * direction,\n            0\n          );\n\n        to = circle(to);\n\n        move(index, width * direction, slideSpeed || speed);\n        move(to, 0, slideSpeed || speed);\n\n        if (continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\n      } else {\n        to = circle(to);\n        animate(index * -width, to * -width, slideSpeed || speed);\n        //no fallback for a circular continuous if the browser does not accept transitions\n      }\n\n      index = to;\n      offloadFn(options.callback && options.callback(index, slides[index]));\n    }\n\n    function move(index, dist, speed) {\n      translate(index, dist, speed);\n      slidePos[index] = dist;\n    }\n\n    function translate(index, dist, speed) {\n      var slide = slides[index];\n      var style = slide && slide.style;\n\n      if (!style) return;\n\n      style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration =\n        speed + 'ms';\n\n      style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';\n      style.msTransform = style.MozTransform = style.OTransform =\n        'translateX(' + dist + 'px)';\n    }\n\n    function animate(from, to, speed) {\n      // if not an animation, just reposition\n      if (!speed) {\n        element.style.left = to + 'px';\n        return;\n      }\n\n      var start = +new Date();\n\n      var timer = setInterval(function() {\n        var timeElap = +new Date() - start;\n\n        if (timeElap > speed) {\n          element.style.left = to + 'px';\n\n          if (delay) begin();\n\n          options.transitionEnd &&\n            options.transitionEnd.call(event, index, slides[index]);\n\n          clearInterval(timer);\n          return;\n        }\n\n        element.style.left =\n          (to - from) * (Math.floor((timeElap / speed) * 100) / 100) +\n          from +\n          'px';\n      }, 4);\n    }\n\n    // setup auto slideshow\n    var delay = options.auto || 0;\n    var interval;\n\n    function begin() {\n      clearTimeout(interval);\n      interval = setTimeout(next, delay);\n    }\n\n    function stop() {\n      delay = 0;\n      clearTimeout(interval);\n    }\n\n    // setup initial vars\n    var start = {};\n    var delta = {};\n    var isScrolling;\n\n    // setup event capturing\n    var events = {\n      handleEvent: function(event) {\n        switch (event.type) {\n          case 'touchstart':\n            this.start(event);\n            break;\n          case 'touchmove':\n            this.move(event);\n            break;\n          case 'touchend':\n            offloadFn(this.end(event));\n            break;\n          case 'webkitTransitionEnd':\n          case 'msTransitionEnd':\n          case 'oTransitionEnd':\n          case 'otransitionend':\n          case 'transitionend':\n            offloadFn(this.transitionEnd(event));\n            break;\n          case 'resize':\n            offloadFn(setup);\n            break;\n        }\n\n        if (options.stopPropagation) event.stopPropagation();\n      },\n      start: function(event) {\n        var touches = event.touches[0];\n\n        // measure start values\n        start = {\n          // get initial touch coords\n          x: touches.pageX,\n          y: touches.pageY,\n\n          // store time to determine touch duration\n          time: +new Date()\n        };\n\n        // used for testing first move event\n        isScrolling = undefined;\n\n        // reset delta and end measurements\n        delta = {};\n\n        // attach touchmove and touchend listeners\n        element.addEventListener('touchmove', this, false);\n        element.addEventListener('touchend', this, false);\n      },\n      move: function(event) {\n        // ensure swiping with one touch and not pinching\n        if (event.touches.length > 1 || (event.scale && event.scale !== 1))\n          return;\n\n        if (options.disableScroll) return;\n\n        var touches = event.touches[0];\n\n        // measure change in x and y\n        delta = {\n          x: touches.pageX - start.x,\n          y: touches.pageY - start.y\n        };\n\n        // determine if scrolling test has run - one time test\n        if (typeof isScrolling == 'undefined') {\n          isScrolling = !!(\n            isScrolling || Math.abs(delta.x) < Math.abs(delta.y)\n          );\n        }\n\n        // if user is not trying to scroll vertically\n        if (!isScrolling) {\n          // prevent native scrolling\n          event.preventDefault();\n\n          // stop slideshow\n          stop();\n\n          // increase resistance if first or last slide\n          if (continuous) {\n            // we don't add resistance at the end\n\n            translate(\n              circle(index - 1),\n              delta.x + slidePos[circle(index - 1)],\n              0\n            );\n            translate(index, delta.x + slidePos[index], 0);\n            translate(\n              circle(index + 1),\n              delta.x + slidePos[circle(index + 1)],\n              0\n            );\n          } else {\n            delta.x =\n              delta.x /\n              ((!index && delta.x > 0) || // if first slide and sliding left\n              (index == slides.length - 1 && // or if last slide and sliding right\n                delta.x < 0) // and if sliding at all\n                ? Math.abs(delta.x) / width + 1 // determine resistance level\n                : 1); // no resistance if false\n\n            // translate 1:1\n            translate(index - 1, delta.x + slidePos[index - 1], 0);\n            translate(index, delta.x + slidePos[index], 0);\n            translate(index + 1, delta.x + slidePos[index + 1], 0);\n          }\n          options.swiping && options.swiping(-delta.x / width);\n        }\n      },\n      end: function(event) {\n        // measure duration\n        var duration = +new Date() - start.time;\n\n        // determine if slide attempt triggers next/prev slide\n        var isValidSlide =\n          (Number(duration) < 250 && // if slide duration is less than 250ms\n            Math.abs(delta.x) > 20) || // and if slide amt is greater than 20px\n          Math.abs(delta.x) > width / 2; // or if slide amt is greater than half the width\n\n        // determine if slide attempt is past start and end\n        var isPastBounds =\n          (!index && delta.x > 0) || // if first slide and slide amt is greater than 0\n          (index == slides.length - 1 && delta.x < 0); // or if last slide and slide amt is less than 0\n\n        if (continuous) isPastBounds = false;\n\n        // determine direction of swipe (true:right, false:left)\n        var direction = delta.x < 0;\n\n        // if not scrolling vertically\n        if (!isScrolling) {\n          if (isValidSlide && !isPastBounds) {\n            if (direction) {\n              if (continuous) {\n                // we need to get the next in this direction in place\n\n                move(circle(index - 1), -width, 0);\n                move(circle(index + 2), width, 0);\n              } else {\n                move(index - 1, -width, 0);\n              }\n\n              move(index, slidePos[index] - width, speed);\n              move(\n                circle(index + 1),\n                slidePos[circle(index + 1)] - width,\n                speed\n              );\n              index = circle(index + 1);\n            } else {\n              if (continuous) {\n                // we need to get the next in this direction in place\n\n                move(circle(index + 1), width, 0);\n                move(circle(index - 2), -width, 0);\n              } else {\n                move(index + 1, width, 0);\n              }\n\n              move(index, slidePos[index] + width, speed);\n              move(\n                circle(index - 1),\n                slidePos[circle(index - 1)] + width,\n                speed\n              );\n              index = circle(index - 1);\n            }\n\n            options.callback && options.callback(index, slides[index]);\n          } else {\n            if (continuous) {\n              move(circle(index - 1), -width, speed);\n              move(index, 0, speed);\n              move(circle(index + 1), width, speed);\n            } else {\n              move(index - 1, -width, speed);\n              move(index, 0, speed);\n              move(index + 1, width, speed);\n            }\n          }\n        }\n\n        // kill touchmove and touchend event listeners until touchstart called again\n        element.removeEventListener('touchmove', events, false);\n        element.removeEventListener('touchend', events, false);\n        element.removeEventListener('touchforcechange', function() {}, false);\n      },\n      transitionEnd: function(event) {\n        if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\n          if (delay) begin();\n\n          options.transitionEnd &&\n            options.transitionEnd.call(event, index, slides[index]);\n        }\n      }\n    };\n\n    // trigger setup\n    setup();\n\n    // start auto slideshow if applicable\n    if (delay) begin();\n\n    // add event listeners\n    if (browser.addEventListener) {\n      // set touchstart event on element\n      if (browser.touch) {\n        element.addEventListener('touchstart', events, false);\n        element.addEventListener('touchforcechange', function() {}, false);\n      }\n\n      if (browser.transitions) {\n        element.addEventListener('webkitTransitionEnd', events, false);\n        element.addEventListener('msTransitionEnd', events, false);\n        element.addEventListener('oTransitionEnd', events, false);\n        element.addEventListener('otransitionend', events, false);\n        element.addEventListener('transitionend', events, false);\n      }\n\n      // set resize event on window\n      window.addEventListener('resize', events, false);\n    } else {\n      window.onresize = function() {\n        setup();\n      }; // to play nice with old IE\n    }\n\n    // expose the Swipe API\n    return {\n      setup: function() {\n        setup();\n      },\n      slide: function(to, speed) {\n        // cancel slideshow\n        stop();\n\n        slide(to, speed);\n      },\n      prev: function() {\n        // cancel slideshow\n        stop();\n\n        prev();\n      },\n      next: function() {\n        // cancel slideshow\n        stop();\n\n        next();\n      },\n      stop: function() {\n        // cancel slideshow\n        stop();\n      },\n      getPos: function() {\n        // return current index position\n        return index;\n      },\n      getNumSlides: function() {\n        // return total number of slides\n        return length;\n      },\n      kill: function() {\n        // cancel slideshow\n        stop();\n\n        // reset element\n        element.style.width = '';\n        element.style.left = '';\n\n        // reset slides\n        var pos = slides.length;\n        while (pos--) {\n          var slide = slides[pos];\n          slide.style.width = '';\n          slide.style.left = '';\n\n          if (browser.transitions) translate(pos, 0, 0);\n        }\n\n        // removed event listeners\n        if (browser.addEventListener) {\n          // remove current event listeners\n          element.removeEventListener('touchstart', events, false);\n          element.removeEventListener('webkitTransitionEnd', events, false);\n          element.removeEventListener('msTransitionEnd', events, false);\n          element.removeEventListener('oTransitionEnd', events, false);\n          element.removeEventListener('otransitionend', events, false);\n          element.removeEventListener('transitionend', events, false);\n          window.removeEventListener('resize', events, false);\n        } else {\n          window.onresize = null;\n        }\n      }\n    };\n  };\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}